테이블의 조회 속도를 높이기 위한 자료구조이다..?

인덱스는 MYI(MySQL Index) 파일에 저장되며 인덱스가 설정되지 않았다면 Table Full Scan이 발생해 성능이 저하될 수 있다

테이블의 조회 속도는 빨라지지만, 생성(INSERT), 수정(UPDATE), 삭제(DELETE) 작업 속도는 저하된다는 단점이 있다. (인덱스의 정보를 갱신해야하기 때문에)

인덱스는 하나의 컬럼 또는 여러개의 컬럼에 설정할 수 있다. WHERE 절을 사용하지 않고 인덱스가 걸린 컬럼을 조회하는것은 성능에 차이가 없다.

또한 인덱스는 GROUP BY와 ORDER BY에도 영향을 미치는데 다음과 같은 경우는 제외된다
- 복수의 키에 대해서 ORDER BY를 사용한 경우
- 연속하지 않은 컬럼에 대해서 ORDER BY를 사용한 경우
- DESC와 ASC를 혼합하여 사용한 경우
- GROUP BY와 ORDER BY하는 컬럼이 다른 경우 
- ORDER BY 절에 다른 표현을 사용한 경우(함수 등)

### 다중 컬럼 인덱스
두개 이상의 필드를 조합해서 생성한 인덱스이며, 1번째 조건과 이를 만족하는 2번째 조건을 INDEX해서 사용한다. 인덱스의 정보를 갱신하는 작업이 단일 컬럼 인덱스보다 더 비효율적이기 때문에 되도록이면 불변값을 인덱스로 사용하는 것이 좋다

STUDENT 테이블에서
name, school 각각 단일 컬럼 인덱스 {key idx_name(name), key idx_name(school)}를 여러개 생성한 것과

name, school로 다중 컬럼 인덱스{key idx_name(name, school)}를 생성한 것과의 차이는

```SQL
SELECT * FROM student where name = "?", schoool = "?";
```

다음과 같은 쿼리에서 차이가 발생한다 각각 단일 컬럼 인덱스를 생성한 경우에는 name 인덱스와 school 인덱스 중에 검색 속도가 빠른 것을 골라 둘중에 하나를 반환하지만, 다중 컬럼 인덱스 같은 경우는 name과 school을 동시에 색인하기 때문에 더 빠른 검색이 가능해진다.

하지만 

```SQL
SELECT * FROM student where school = "?";
```

위와 같은 경우에서는 다중 컬럼 인덱스가 작동하지 않는다. 이유는 인덱스가 Binary Tree 구조로 이루어져있기 때문에 인덱스를 생성할 때 정한 순서대로 다음과 같은 ```SELECT * FROM student where name = "?";```과  쿼리에서는 인덱스가 동작한다.

### 인덱스 설정 시 주의해야 할 사항

* 한 테이블 당 3~5개가 적정
* 조회에 자주 사용되는 컬럼
- 카디널리티가 낮으면 좋다
- Index의 크기를 최대한 작게 설계한다
- PK, JOIN의 연결점이 되는 컬럼으로 설정
- 다중 컬럼 인덱스 > 단일 컬럼 인덱스 N개
- UPDATE가 빈번하지 않은 컬럼
- 정수형 자료형이 Index 걸기에 가장 효율적